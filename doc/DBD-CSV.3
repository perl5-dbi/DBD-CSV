.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.40)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "STDIN 1"
.TH STDIN 1 "2020-07-24" "perl v5.32.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::CSV \- DBI driver for CSV files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    use DBI;
\&    # See "Creating database handle" below
\&    $dbh = DBI\->connect ("dbi:CSV:", undef, undef, {
\&        f_ext      => ".csv/r",
\&        RaiseError => 1,
\&        }) or die "Cannot connect: $DBI::errstr";
\&
\&    # Simple statements
\&    $dbh\->do ("CREATE TABLE foo (id INTEGER, name CHAR (10))");
\&
\&    # Selecting
\&    my $sth = $dbh\->prepare ("select * from foo");
\&    $sth\->execute;
\&    $sth\->bind_columns (\emy ($id, $name));
\&    while ($sth\->fetch) {
\&        print "id: $id, name: $name\en";
\&        }
\&
\&    # Updates
\&    my $sth = $dbh\->prepare ("UPDATE foo SET name = ? WHERE id = ?");
\&    $sth\->execute ("DBI rocks!", 1);
\&    $sth\->finish;
\&
\&    $dbh\->disconnect;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1DBD::CSV\s0 module is yet another driver for the \s-1DBI\s0 (Database independent
interface for Perl). This one is based on the \s-1SQL\s0 \*(L"engine\*(R" SQL::Statement
and the abstract \s-1DBI\s0 driver DBD::File and implements access to so-called
\&\s-1CSV\s0 files (Comma Separated Values). Such files are often used for exporting
\&\s-1MS\s0 Access and \s-1MS\s0 Excel data.
.PP
See \s-1DBI\s0 for details on \s-1DBI,\s0 SQL::Statement for details on
SQL::Statement and DBD::File for details on the base class DBD::File.
.SS "Prerequisites"
.IX Subsection "Prerequisites"
The only system dependent feature that DBD::File uses, is the \f(CW\*(C`flock ()\*(C'\fR
function. Thus the module should run (in theory) on any system with
a working \f(CW\*(C`flock ()\*(C'\fR, in particular on all Unix machines and on Windows
\&\s-1NT.\s0 Under Windows 95 and MacOS the use of \f(CW\*(C`flock ()\*(C'\fR is disabled, thus
the module should still be usable.
.PP
Unlike other \s-1DBI\s0 drivers, you don't need an external \s-1SQL\s0 engine or a
running server. All you need are the following Perl modules, available
from any \s-1CPAN\s0 mirror, for example
.PP
.Vb 1
\&  http://search.cpan.org/
.Ve
.IP "\s-1DBI\s0" 4
.IX Xref "DBI"
.IX Item "DBI"
A recent version of the \s-1DBI\s0 (Database independent interface for Perl).
See below why.
.IP "DBD::File" 4
.IX Xref "DBD::File"
.IX Item "DBD::File"
This is the base class for \s-1DBD::CSV,\s0 and it is part of the \s-1DBI\s0
distribution. As \s-1DBD::CSV\s0 requires a matching version of DBD::File
which is (partly) developed by the same team that maintains
\&\s-1DBD::CSV.\s0 See \s-1META\s0.json or Makefile.PL for the minimum versions.
.IP "SQL::Statement" 4
.IX Xref "SQL::Statement"
.IX Item "SQL::Statement"
A simple \s-1SQL\s0 engine. This module defines all of the \s-1SQL\s0 syntax for
\&\s-1DBD::CSV,\s0 new \s-1SQL\s0 support is added with each release so you should
look for updates to SQL::Statement regularly.
.Sp
It is possible to run \f(CW\*(C`DBD::CSV\*(C'\fR without this module if you define
the environment variable \f(CW$DBI_SQL_NANO\fR to 1. This will reduce the
\&\s-1SQL\s0 support a lot though. See DBI::SQL::Nano for more details. Note
that the test suite does only test in this mode in the development
environment.
.IP "Text::CSV_XS" 4
.IX Xref "Text::CSV_XS"
.IX Item "Text::CSV_XS"
This module is used to read and write rows in a \s-1CSV\s0 file.
.SS "Installation"
.IX Subsection "Installation"
Installing this module (and the prerequisites from above) is quite simple.
The simplest way is to install the bundle:
.PP
.Vb 1
\&    $ cpan Bundle::DBD::CSV
.Ve
.PP
Alternatively, you can name them all
.PP
.Vb 1
\&    $ cpan Text::CSV_XS DBI DBD::CSV
.Ve
.PP
or even trust \f(CW\*(C`cpan\*(C'\fR to resolve all dependencies for you:
.PP
.Vb 1
\&    $ cpan DBD::CSV
.Ve
.PP
If you cannot, for whatever reason, use cpan, fetch all modules from
\&\s-1CPAN,\s0 and build with a sequence like:
.PP
.Vb 1
\&    gzip \-d < DBD\-CSV\-0.40.tgz | tar xf \-
.Ve
.PP
(this is for Unix users, Windows users would prefer WinZip or something
similar) and then enter the following:
.PP
.Vb 3
\&    cd DBD\-CSV\-0.40
\&    perl Makefile.PL
\&    make test
.Ve
.PP
If any tests fail, let us know. Otherwise go on with
.PP
.Vb 1
\&    make install UNINST=1
.Ve
.PP
Note that you almost definitely need root or administrator permissions.
If you don't have them, read the ExtUtils::MakeMaker man page for details
on installing in your own directories. ExtUtils::MakeMaker.
.SS "Supported \s-1SQL\s0 Syntax"
.IX Subsection "Supported SQL Syntax"
All \s-1SQL\s0 processing for \s-1DBD::CSV\s0 is done by SQL::Statement. See
SQL::Statement for more specific information about its feature set.
Features include joins, aliases, built-in and user-defined functions,
and more.  See SQL::Statement::Syntax for a description of the \s-1SQL\s0
syntax supported in \s-1DBD::CSV.\s0
.PP
Table\- and column-names are case insensitive unless quoted. Column names
will be sanitized unless \*(L"raw_header\*(R" is true.
.SH "Using DBD::CSV with DBI"
.IX Header "Using DBD::CSV with DBI"
For most things, DBD-CSV operates the same as any \s-1DBI\s0 driver.
See \s-1DBI\s0 for detailed usage.
.SS "Creating a database handle (connect)"
.IX Subsection "Creating a database handle (connect)"
Creating a database handle usually implies connecting to a database server.
Thus this command reads
.PP
.Vb 4
\&    use DBI;
\&    my $dbh = DBI\->connect ("dbi:CSV:", "", "", {
\&        f_dir => "/home/user/folder",
\&        });
.Ve
.PP
The directory tells the driver where it should create or open tables (a.k.a.
files). It defaults to the current directory, so the following are equivalent:
.PP
.Vb 3
\&    $dbh = DBI\->connect ("dbi:CSV:");
\&    $dbh = DBI\->connect ("dbi:CSV:", undef, undef, { f_dir => "." });
\&    $dbh = DBI\->connect ("dbi:CSV:f_dir=.");
.Ve
.PP
We were told, that \s-1VMS\s0 might \- for whatever reason \- require:
.PP
.Vb 1
\&    $dbh = DBI\->connect ("dbi:CSV:f_dir=");
.Ve
.PP
The preferred way of passing the arguments is by driver attributes:
.PP
.Vb 8
\&    # specify most possible flags via driver flags
\&    $dbh = DBI\->connect ("dbi:CSV:", undef, undef, {
\&        f_schema         => undef,
\&        f_dir            => "data",
\&        f_dir_search     => [],
\&        f_ext            => ".csv/r",
\&        f_lock           => 2,
\&        f_encoding       => "utf8",
\&
\&        csv_eol          => "\er\en",
\&        csv_sep_char     => ",",
\&        csv_quote_char   => \*(Aq"\*(Aq,
\&        csv_escape_char  => \*(Aq"\*(Aq,
\&        csv_class        => "Text::CSV_XS",
\&        csv_null         => 1,
\&        csv_bom          => 0,
\&        csv_tables       => {
\&            syspwd => {
\&                sep_char    => ":",
\&                quote_char  => undef,
\&                escape_char => undef,
\&                file        => "/etc/passwd",
\&                col_names   => [qw( login password
\&                                    uid gid realname
\&                                    directory shell )],
\&                },
\&            },
\&
\&        RaiseError       => 1,
\&        PrintError       => 1,
\&        FetchHashKeyName => "NAME_lc",
\&        }) or die $DBI::errstr;
.Ve
.PP
but you may set these attributes in the \s-1DSN\s0 as well, separated by semicolons.
Pay attention to the semi-colon for \f(CW\*(C`csv_sep_char\*(C'\fR (as seen in many \s-1CSV\s0
exports from \s-1MS\s0 Excel) is being escaped in below example, as is would
otherwise be seen as attribute separator:
.PP
.Vb 5
\&    $dbh = DBI\->connect (
\&        "dbi:CSV:f_dir=$ENV{HOME}/csvdb;f_ext=.csv;f_lock=2;" .
\&        "f_encoding=utf8;csv_eol=\en;csv_sep_char=\e\e;;" .
\&        "csv_quote_char=\e";csv_escape_char=\e\e;csv_class=Text::CSV_XS;" .
\&        "csv_null=1") or die $DBI::errstr;
.Ve
.PP
Using attributes in the \s-1DSN\s0 is easier to use when the \s-1DSN\s0 is derived from an
outside source (environment variable, database entry, or configure file),
whereas specifying entries in the attribute hash is easier to read and to
maintain.
.PP
The default value for \f(CW\*(C`csv_binary\*(C'\fR is \f(CW1\fR (True).
.PP
The default value for \f(CW\*(C`csv_auto_diag\*(C'\fR is <1>. Note that this might cause
trouble on perl versions older than 5.8.9, so up to and including perl
version 5.8.8 it might be required to use \f(CW\*(C`;csv_auto_diag=0\*(C'\fR inside the
\&\f(CW\*(C`DSN\*(C'\fR or \f(CW\*(C`csv_auto_diag =\*(C'\fR 0> inside the attributes.
.SS "Creating and dropping tables"
.IX Subsection "Creating and dropping tables"
You can create and drop tables with commands like the following:
.PP
.Vb 2
\&    $dbh\->do ("CREATE TABLE $table (id INTEGER, name CHAR (64))");
\&    $dbh\->do ("DROP TABLE $table");
.Ve
.PP
Note that currently only the column names will be stored and no other data.
Thus all other information including column type (\s-1INTEGER\s0 or \s-1CHAR\s0 (x), for
example), column attributes (\s-1NOT NULL, PRIMARY KEY, ...\s0) will silently be
discarded. This may change in a later release.
.PP
A drop just removes the file without any warning.
.PP
See \s-1DBI\s0 for more details.
.PP
Table names cannot be arbitrary, due to restrictions of the \s-1SQL\s0 syntax.
I recommend that table names are valid \s-1SQL\s0 identifiers: The first
character is alphabetic, followed by an arbitrary number of alphanumeric
characters. If you want to use other files, the file names must start
with \*(L"/\*(R", \*(L"./\*(R" or \*(L"../\*(R" and they must not contain white space.
.SS "Inserting, fetching and modifying data"
.IX Subsection "Inserting, fetching and modifying data"
The following examples insert some data in a table and fetch it back:
First, an example where the column data is concatenated in the \s-1SQL\s0 string:
.PP
.Vb 2
\&    $dbh\->do ("INSERT INTO $table VALUES (1, ".
\&               $dbh\->quote ("foobar") . ")");
.Ve
.PP
Note the use of the quote method for escaping the word \*(L"foobar\*(R". Any
string must be escaped, even if it does not contain binary data.
.PP
Next, an example using parameters:
.PP
.Vb 2
\&    $dbh\->do ("INSERT INTO $table VALUES (?, ?)", undef, 2,
\&              "It\*(Aqs a string!");
.Ve
.PP
Note that you don't need to quote column data passed as parameters.
This version is particularly well designed for
loops. Whenever performance is an issue, I recommend using this method.
.PP
You might wonder about the \f(CW\*(C`undef\*(C'\fR. Don't wonder, just take it as it
is. :\-) It's an attribute argument that I have never used and will be
passed to the prepare method as the second argument.
.PP
To retrieve data, you can use the following:
.PP
.Vb 8
\&    my $query = "SELECT * FROM $table WHERE id > 1 ORDER BY id";
\&    my $sth   = $dbh\->prepare ($query);
\&    $sth\->execute ();
\&    while (my $row = $sth\->fetchrow_hashref) {
\&        print "Found result row: id = ", $row\->{id},
\&              ", name = ", $row\->{name};
\&        }
\&    $sth\->finish ();
.Ve
.PP
Again, column binding works: The same example again.
.PP
.Vb 10
\&    my $sth = $dbh\->prepare (qq;
\&        SELECT * FROM $table WHERE id > 1 ORDER BY id;
\&        ;);
\&    $sth\->execute;
\&    my ($id, $name);
\&    $sth\->bind_columns (undef, \e$id, \e$name);
\&    while ($sth\->fetch) {
\&        print "Found result row: id = $id, name = $name\en";
\&        }
\&    $sth\->finish;
.Ve
.PP
Of course you can even use input parameters. Here's the same example
for the third time:
.PP
.Vb 9
\&    my $sth = $dbh\->prepare ("SELECT * FROM $table WHERE id = ?");
\&    $sth\->bind_columns (undef, \e$id, \e$name);
\&    for (my $i = 1; $i <= 2; $i++) {
\&        $sth\->execute ($id);
\&        if ($sth\->fetch) {
\&            print "Found result row: id = $id, name = $name\en";
\&            }
\&        $sth\->finish;
\&        }
.Ve
.PP
See \s-1DBI\s0 for details on these methods. See SQL::Statement for
details on the \s-1WHERE\s0 clause.
.PP
Data rows are modified with the \s-1UPDATE\s0 statement:
.PP
.Vb 1
\&    $dbh\->do ("UPDATE $table SET id = 3 WHERE id = 1");
.Ve
.PP
Likewise you use the \s-1DELETE\s0 statement for removing rows:
.PP
.Vb 1
\&    $dbh\->do ("DELETE FROM $table WHERE id > 1");
.Ve
.SS "Error handling"
.IX Subsection "Error handling"
In the above examples we have never cared about return codes. Of
course, this is not recommended. Instead we should have written (for
example):
.PP
.Vb 11
\&    my $sth = $dbh\->prepare ("SELECT * FROM $table WHERE id = ?") or
\&        die "prepare: " . $dbh\->errstr ();
\&    $sth\->bind_columns (undef, \e$id, \e$name) or
\&        die "bind_columns: " . $dbh\->errstr ();
\&    for (my $i = 1; $i <= 2; $i++) {
\&        $sth\->execute ($id) or
\&            die "execute: " . $dbh\->errstr ();
\&        $sth\->fetch and
\&            print "Found result row: id = $id, name = $name\en";
\&        }
\&    $sth\->finish ($id) or die "finish: " . $dbh\->errstr ();
.Ve
.PP
Obviously this is tedious. Fortunately we have \s-1DBI\s0's \fIRaiseError\fR
attribute:
.PP
.Vb 10
\&    $dbh\->{RaiseError} = 1;
\&    $@ = "";
\&    eval {
\&        my $sth = $dbh\->prepare ("SELECT * FROM $table WHERE id = ?");
\&        $sth\->bind_columns (undef, \e$id, \e$name);
\&        for (my $i = 1; $i <= 2; $i++) {
\&            $sth\->execute ($id);
\&            $sth\->fetch and
\&                print "Found result row: id = $id, name = $name\en";
\&            }
\&        $sth\->finish ($id);
\&        };
\&    $@ and die "SQL database error: $@";
.Ve
.PP
This is not only shorter, it even works when using \s-1DBI\s0 methods within
subroutines.
.SH "DBI database handle attributes"
.IX Header "DBI database handle attributes"
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by DBD::File,
thus they all work as expected:
.PP
.Vb 9
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
The following \s-1DBI\s0 attributes are handled by DBD::File:
.IP "AutoCommit" 4
.IX Xref "AutoCommit"
.IX Item "AutoCommit"
Always on
.IP "ChopBlanks" 4
.IX Xref "ChopBlanks"
.IX Item "ChopBlanks"
Works
.IP "\s-1NUM_OF_FIELDS\s0" 4
.IX Xref "NUM_OF_FIELDS"
.IX Item "NUM_OF_FIELDS"
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR
.IP "\s-1NUM_OF_PARAMS\s0" 4
.IX Xref "NUM_OF_PARAMS"
.IX Item "NUM_OF_PARAMS"
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR
.IP "\s-1NAME\s0" 4
.IX Xref "NAME"
.IX Item "NAME"
.PD 0
.IP "NAME_lc" 4
.IX Xref "NAME_lc"
.IX Item "NAME_lc"
.IP "NAME_uc" 4
.IX Xref "NAME_uc"
.IX Item "NAME_uc"
.PD
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for Non-Select statements.
.IP "\s-1NULLABLE\s0" 4
.IX Xref "NULLABLE"
.IX Item "NULLABLE"
Not really working. Always returns an array ref of one's, as \s-1DBD::CSV\s0
does not verify input data. Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for
non-Select statements.
.PP
These attributes and methods are not supported:
.PP
.Vb 4
\&    bind_param_inout
\&    CursorName
\&    LongReadLen
\&    LongTruncOk
.Ve
.SH "DBD-CSV specific database handle attributes"
.IX Header "DBD-CSV specific database handle attributes"
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.SS "DBD::File attributes"
.IX Subsection "DBD::File attributes"
.IP "f_dir" 4
.IX Xref "f_dir"
.IX Item "f_dir"
This attribute is used for setting the directory where \s-1CSV\s0 files are
opened. Usually you set it in the dbh and it defaults to the current
directory (\*(L".\*(R"). However, it may be overridden in statement handles.
.IP "f_dir_search" 4
.IX Xref "f_dir_search"
.IX Item "f_dir_search"
This attribute optionally defines a list of extra directories to search
when opening existing tables. It should be an anonymous list or an array
reference listing all folders where tables could be found.
.Sp
.Vb 5
\&    my $dbh = DBI\->connect ("dbi:CSV:", "", "", {
\&        f_dir        => "data",
\&        f_dir_search => [ "ref/data", "ref/old" ],
\&        f_ext        => ".csv/r",
\&        }) or die $DBI::errstr;
.Ve
.IP "f_ext" 4
.IX Xref "f_ext"
.IX Item "f_ext"
This attribute is used for setting the file extension.
.IP "f_schema" 4
.IX Xref "f_schema"
.IX Item "f_schema"
This attribute allows you to set the database schema name. The default is
to use the owner of \f(CW\*(C`f_dir\*(C'\fR. \f(CW\*(C`undef\*(C'\fR is allowed, but not in the \s-1DSN\s0 part.
.Sp
.Vb 5
\&    my $dbh = DBI\->connect ("dbi:CSV:", "", "", {
\&        f_schema => undef,
\&        f_dir    => "data",
\&        f_ext    => ".csv/r",
\&        }) or die $DBI::errstr;
.Ve
.IP "f_encoding" 4
.IX Xref "f_encoding"
.IX Item "f_encoding"
This attribute allows you to set the encoding of the data. With \s-1CSV,\s0 it is not
possible to set (and remember) the encoding on a column basis, but DBD::File
now allows the encoding to be set on the underlying file. If this attribute is
not set, or undef is passed, the file will be seen as binary.
.IP "f_lock" 4
.IX Xref "f_lock"
.IX Item "f_lock"
With this attribute you can specify a locking mode to be used (if locking is
supported at all) for opening tables. By default, tables are opened with a
shared lock for reading, and with an exclusive lock for writing. The
supported modes are:
.RS 4
.IP "0" 2
.IX Xref "0"
Force no locking at all.
.IP "1" 2
.IX Xref "1"
.IX Item "1"
Only shared locks will be used.
.IP "2" 2
.IX Xref "2"
.IX Item "2"
Only exclusive locks will be used.
.RE
.RS 4
.RE
.PP
But see \*(L"\s-1KNOWN BUGS\*(R"\s0 in DBD::File.
.SS "\s-1DBD::CSV\s0 specific attributes"
.IX Subsection "DBD::CSV specific attributes"
.IP "csv_class" 4
.IX Item "csv_class"
The attribute \fIcsv_class\fR controls the \s-1CSV\s0 parsing engine. This defaults
to \f(CW\*(C`Text::CSV_XS\*(C'\fR, but \f(CW\*(C`Text::CSV\*(C'\fR can be used in some cases, too.
Please be aware that \f(CW\*(C`Text::CSV\*(C'\fR does not care about any edge case as
\&\f(CW\*(C`Text::CSV_XS\*(C'\fR does and that \f(CW\*(C`Text::CSV\*(C'\fR is probably about 100 times
slower than \f(CW\*(C`Text::CSV_XS\*(C'\fR.
.SS "Text::CSV_XS specific attributes"
.IX Subsection "Text::CSV_XS specific attributes"
.IP "csv_eol" 4
.IX Xref "csv_eol"
.IX Item "csv_eol"
.PD 0
.IP "csv_sep_char" 4
.IX Xref "csv_sep_char"
.IX Item "csv_sep_char"
.IP "csv_quote_char" 4
.IX Xref "csv_quote_char"
.IX Item "csv_quote_char"
.IP "csv_escape_char" 4
.IX Xref "csv_escape_char"
.IX Item "csv_escape_char"
.IP "csv_csv" 4
.IX Xref "csv_csv"
.IX Item "csv_csv"
.PD
The attributes \fIcsv_eol\fR, \fIcsv_sep_char\fR, \fIcsv_quote_char\fR and
\&\fIcsv_escape_char\fR are corresponding to the respective attributes of the
\&\fIcsv_class\fR (usually Text::CSV_CS) object. You may want to set these
attributes if you have unusual \s-1CSV\s0 files like \fI/etc/passwd\fR or \s-1MS\s0 Excel
generated \s-1CSV\s0 files with a semicolon as separator. Defaults are
\&\f(CW\*(C`\e015\e012\*(C'\fR", \f(CW\*(C`,\*(C'\fR, \f(CW\*(C`"\*(C'\fR and \f(CW\*(C`"\*(C'\fR, respectively.
.Sp
The \fIcsv_eol\fR attribute defines the end-of-line pattern, which is better
known as a record separator pattern since it separates records.  The default
is windows-style end-of-lines \f(CW\*(C`\e015\e012\*(C'\fR for output (writing) and unset for
input (reading), so if on unix you may want to set this to newline (\f(CW\*(C`\en\*(C'\fR)
like this:
.Sp
.Vb 1
\&  $dbh\->{csv_eol} = "\en";
.Ve
.Sp
It is also possible to use multi-character patterns as record separators.
For example this file uses newlines as field separators (sep_char) and
the pattern \*(L"\en_\|_ENDREC_\|_\en\*(R" as the record separators (eol):
.Sp
.Vb 9
\&  name
\&  city
\&  _\|_ENDREC_\|_
\&  joe
\&  seattle
\&  _\|_ENDREC_\|_
\&  sue
\&  portland
\&  _\|_ENDREC_\|_
.Ve
.Sp
To handle this file, you'd do this:
.Sp
.Vb 2
\&  $dbh\->{eol}      = "\en_\|_ENDREC_\|_\en" ,
\&  $dbh\->{sep_char} = "\en"
.Ve
.Sp
The attributes are used to create an instance of the class \fIcsv_class\fR,
by default Text::CSV_XS. Alternatively you may pass an instance as
\&\fIcsv_csv\fR, the latter takes precedence. Note that the \fIbinary\fR
attribute \fImust\fR be set to a true value in that case.
.Sp
Additionally you may overwrite these attributes on a per-table base in
the \fIcsv_tables\fR attribute.
.IP "csv_null" 4
.IX Xref "csv_null"
.IX Item "csv_null"
With this option set, all new statement handles will set \f(CW\*(C`always_quote\*(C'\fR
and \f(CW\*(C`blank_is_undef\*(C'\fR in the \s-1CSV\s0 parser and writer, so it knows how to
distinguish between the empty string and \f(CW\*(C`undef\*(C'\fR or \f(CW\*(C`NULL\*(C'\fR. You cannot
reset it with a false value. You can pass it to connect, or set it later:
.Sp
.Vb 1
\&  $dbh = DBI\->connect ("dbi:CSV:", "", "", { csv_null => 1 });
\&
\&  $dbh\->{csv_null} = 1;
.Ve
.IP "csv_bom" 4
.IX Xref "csv_bom"
.IX Item "csv_bom"
With this option set, the \s-1CSV\s0 parser will try to detect \s-1BOM\s0 (Byte Order Mark)
in the header line. This requires Text::CSV_XS version 1.22 or higher.
.Sp
.Vb 1
\&  $dbh = DBI\->connect ("dbi:CSV:", "", "", { csv_bom => 1 });
\&
\&  $dbh\->{csv_bom} = 1;
.Ve
.IP "csv_tables" 4
.IX Xref "csv_tables"
.IX Item "csv_tables"
This hash ref is used for storing table dependent metadata. For any
table it contains an element with the table name as key and another
hash ref with the following attributes:
.RS 4
.IP "o" 4
.IX Item "o"
All valid attributes to the \s-1CSV\s0 parsing module. Any of them can optionally
be prefixed with \f(CW\*(C`csv_\*(C'\fR.
.IP "o" 4
.IX Item "o"
All attributes valid to DBD::File
.RE
.RS 4
.Sp
If you pass it \f(CW\*(C`f_file\*(C'\fR or its alias \f(CW\*(C`file\*(C'\fR, \f(CW\*(C`f_ext\*(C'\fR has no effect, but
\&\f(CW\*(C`f_dir\*(C'\fR and \f(CW\*(C`f_encoding\*(C'\fR still have.
.Sp
.Vb 11
\&  csv_tables => {
\&      syspwd => {                   # Table name
\&          csv_sep_char => ":",      # Text::CSV_XS
\&          quote_char   => undef,    # Text::CSV_XS
\&          escape_char  => undef,    # Text::CSV_XS
\&          f_dir        => "/etc",   # DBD::File
\&          f_file       => "passwd", # DBD::File
\&          col_names    =>           # DBD::File
\&            [qw( login password uid gid realname directory shell )],
\&          },
\&      },
.Ve
.RE
.IP "csv_*" 4
.IX Xref "csv_*"
.IX Item "csv_*"
All other attributes that start with \f(CW\*(C`csv_\*(C'\fR and are not described above
will be passed to \f(CW\*(C`Text::CSV_XS\*(C'\fR (without the \f(CW\*(C`csv_\*(C'\fR prefix). These
extra options are only likely to be useful for reading (select)
handles. Examples:
.Sp
.Vb 3
\&  $dbh\->{csv_allow_whitespace}    = 1;
\&  $dbh\->{csv_allow_loose_quotes}  = 1;
\&  $dbh\->{csv_allow_loose_escapes} = 1;
.Ve
.Sp
See the \f(CW\*(C`Text::CSV_XS\*(C'\fR documentation for the full list and the documentation.
.SS "Driver specific attributes"
.IX Subsection "Driver specific attributes"
.IP "f_file" 4
.IX Xref "f_file"
.IX Item "f_file"
The name of the file used for the table; defaults to
.Sp
.Vb 1
\&    "$dbh\->{f_dir}/$table"
.Ve
.IP "eol" 4
.IX Xref "eol"
.IX Item "eol"
.PD 0
.IP "sep_char" 4
.IX Xref "sep_char"
.IX Item "sep_char"
.IP "quote_char" 4
.IX Xref "quote_char"
.IX Item "quote_char"
.IP "escape_char" 4
.IX Xref "escape_char"
.IX Item "escape_char"
.IP "class" 4
.IX Xref "class"
.IX Item "class"
.IP "csv" 4
.IX Xref "csv"
.IX Item "csv"
.PD
These correspond to the attributes \fIcsv_eol\fR, \fIcsv_sep_char\fR,
\&\fIcsv_quote_char\fR, \fIcsv_escape_char\fR, \fIcsv_class\fR and \fIcsv_csv\fR.
The difference is that they work on a per-table basis.
.IP "col_names" 4
.IX Xref "col_names"
.IX Item "col_names"
.PD 0
.IP "skip_first_row" 4
.IX Xref "skip_first_row"
.IX Item "skip_first_row"
.PD
By default \s-1DBD::CSV\s0 assumes that column names are stored in the first row
of the \s-1CSV\s0 file and sanitizes them (see \f(CW\*(C`raw_header\*(C'\fR below). If this is
not the case, you can supply an array ref of table names with the
\&\fIcol_names\fR attribute. In that case the attribute \fIskip_first_row\fR will
be set to \s-1FALSE.\s0
.Sp
If you supply an empty array ref, the driver will read the first row
for you, count the number of columns and create column names like
\&\f(CW\*(C`col0\*(C'\fR, \f(CW\*(C`col1\*(C'\fR, ...
.Sp
Note that column names that match reserved \s-1SQL\s0 words will cause unwanted
and sometimes confusing errors. If your \s-1CSV\s0 has headers that match reserved
words, you will require these two attributes.
.Sp
If \f(CW\*(C`test.csv\*(C'\fR looks like
.Sp
.Vb 2
\& select,from
\& 1,2
.Ve
.Sp
the select query would result in \f(CW\*(C`select select, from from test;\*(C'\fR, which
obviously is illegal \s-1SQL.\s0
.IP "raw_header" 4
.IX Xref "raw_header"
.IX Item "raw_header"
Due to the \s-1SQL\s0 standard, field names cannot contain special characters
like a dot (\f(CW\*(C`.\*(C'\fR) or a space (\f(CW\*(C` \*(C'\fR) unless the column names are quoted.
Following the approach of mdb_tools, all these tokens are translated to an
underscore (\f(CW\*(C`_\*(C'\fR) when reading the first line of the \s-1CSV\s0 file, so all field
names are 'sanitized'. If you do not want this to happen, set \f(CW\*(C`raw_header\*(C'\fR
to a true value and the entries in the first line of the \s-1CSV\s0 data will be
used verbatim for column headers and field names.  \s-1DBD::CSV\s0 cannot guarantee
that any part in the toolchain will work if field names have those characters,
and the chances are high that the \s-1SQL\s0 statements will fail.
.Sp
Currently, the sanitizing of headers is as simple as
.Sp
.Vb 1
\&  s/\eW/_/g;
.Ve
.Sp
Note that headers (column names) might be folded in other parts of the code
stack, specifically SQL::Statement, whose docs mention:
.Sp
.Vb 2
\& Wildcards are expanded to lower cased identifiers. This might
\& confuse some people, but it was easier to implement.
.Ve
.Sp
That means that in
.Sp
.Vb 5
\& my $sth = $dbh\->prepare ("select * from foo");
\& $sth\->execute;
\& while (my $row = $sth\->fetchrow_hashref) {
\&     say for keys %$row;
\&     }
.Ve
.Sp
all keys will show as all lower case, regardless of the original header.
.PP
It's strongly recommended to check the attributes supported by
\&\*(L"Metadata\*(R" in DBD::File.
.PP
Example: Suppose you want to use \fI/etc/passwd\fR as a \s-1CSV\s0 file. :\-)
There simplest way is:
.PP
.Vb 12
\&    use DBI;
\&    my $dbh = DBI\->connect ("dbi:CSV:", undef, undef, {
\&        f_dir           => "/etc",
\&        csv_sep_char    => ":",
\&        csv_quote_char  => undef,
\&        csv_escape_char => undef,
\&        });
\&    $dbh\->{csv_tables}{passwd} = {
\&        col_names => [qw( login password uid gid realname
\&                          directory shell )];
\&        };
\&    $sth = $dbh\->prepare ("SELECT * FROM passwd");
.Ve
.PP
Another possibility where you leave all the defaults as they are and
override them on a per table basis:
.PP
.Vb 12
\&    require DBI;
\&    my $dbh = DBI\->connect ("dbi:CSV:");
\&    $dbh\->{csv_tables}{passwd} = {
\&        eol         => "\en",
\&        sep_char    => ":",
\&        quote_char  => undef,
\&        escape_char => undef,
\&        f_file      => "/etc/passwd",
\&        col_names   => [qw( login password uid gid
\&                            realname directory shell )],
\&        };
\&    $sth = $dbh\->prepare ("SELECT * FROM passwd");
.Ve
.SS "Driver private methods"
.IX Subsection "Driver private methods"
These methods are inherited from DBD::File:
.IP "data_sources" 4
.IX Xref "data_sources"
.IX Item "data_sources"
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of sub-directories of the current
directory in the form \*(L"dbi:CSV:directory=$dirname\*(R".
.Sp
If you want to read the sub-directories of another directory, use
.Sp
.Vb 2
\&    my $drh  = DBI\->install_driver ("CSV");
\&    my @list = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.IP "list_tables" 4
.IX Xref "list_tables"
.IX Item "list_tables"
This method returns a list of file-names inside \f(CW$dbh\fR\->{directory}.
Example:
.Sp
.Vb 2
\&    my $dbh  = DBI\->connect ("dbi:CSV:directory=/usr/local/csv_data");
\&    my @list = $dbh\->func ("list_tables");
.Ve
.Sp
Note that the list includes all files contained in the directory, even
those that have non-valid table names, from the view of \s-1SQL.\s0 See
\&\*(L"Creating and dropping tables\*(R" above.
.SH "KNOWN ISSUES"
.IX Header "KNOWN ISSUES"
.IP "\(bu" 4
The module is using flock () internally. However, this function is not
available on some platforms. Use of flock () is disabled on MacOS and
Windows 95: There's no locking at all (perhaps not so important on
these operating systems, as they are for single users anyways).
.SH "TODO"
.IX Header "TODO"
.IP "Tests" 4
.IX Xref "Tests"
.IX Item "Tests"
Aim for a full 100% code coverage
.Sp
.Vb 8
\& \- eol      Make tests for different record separators.
\& \- csv_xs   Test with a variety of combinations for
\&            sep_char, quote_char, and escape_char testing
\& \- quoting  $dbh\->do ("drop table $_") for DBI\-tables ();
\& \- errors   Make sure that all documented exceptions are tested.
\&            . write to write\-protected file
\&            . read from badly formatted csv
\&            . pass bad arguments to csv parser while fetching
.Ve
.Sp
Add tests that specifically test DBD::File functionality where
that is useful.
.IP "\s-1RT\s0" 4
.IX Xref "RT"
.IX Item "RT"
Attack all open \s-1DBD::CSV\s0 bugs in \s-1RT\s0
.IP "CPAN::Forum" 4
.IX Xref "CPAN::Forum"
.IX Item "CPAN::Forum"
Attack all items in http://www.cpanforum.com/dist/DBD\-CSV
.IP "Documentation" 4
.IX Xref "Documentation"
.IX Item "Documentation"
Expand on error-handling, and document all possible errors.
Use Text::CSV_XS::error_diag () wherever possible.
.IP "Debugging" 4
.IX Xref "Debugging"
.IX Item "Debugging"
Implement and document dbd_verbose.
.IP "Data dictionary" 4
.IX Xref "Data dictionary"
.IX Item "Data dictionary"
Investigate the possibility to store the data dictionary in a file like
\&.sys$columns that can store the field attributes (type, key, nullable).
.IP "Examples" 4
.IX Xref "Examples"
.IX Item "Examples"
Make more real-life examples from the docs in examples/
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, Text::CSV_XS, SQL::Statement, DBI::SQL::Nano
.PP
For help on the use of \s-1DBD::CSV,\s0 see the \s-1DBI\s0 users mailing list:
.PP
.Vb 1
\&  http://lists.cpan.org/showlist.cgi?name=dbi\-users
.Ve
.PP
For general information on \s-1DBI\s0 see
.PP
.Vb 1
\&  http://dbi.perl.org/ and http://faq.dbi\-support.com/
.Ve
.SH "AUTHORS and MAINTAINERS"
.IX Header "AUTHORS and MAINTAINERS"
This module is currently maintained by
.PP
.Vb 1
\&    H.Merijn Brand <h.m.brand@xs4all.nl>
.Ve
.PP
in close cooperation with and help from
.PP
.Vb 1
\&    Jens Rehsack <sno@NetBSD.org>
.Ve
.PP
The original author is Jochen Wiedmann.
Previous maintainer was Jeff Zucker
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2009\-2020 by H.Merijn Brand
Copyright (C) 2004\-2009 by Jeff Zucker
Copyright (C) 1998\-2004 by Jochen Wiedmann
.PP
All rights reserved.
.PP
You may distribute this module under the terms of either the \s-1GNU\s0
General Public License or the Artistic License, as specified in
the Perl \s-1README\s0 file.
